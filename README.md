初始化：
        首先定义一个一维数组BUF，将其地址，长度和最长数据帧长度交给FIFO_buf_by_normal_buf函数，生成一个控制结构。最长数据帧
    长度不超过BUF长度的一半，BUF可以设大些，数据帧长度也可以留冗余。

简便用法：
        中断内使用单字节快速写入（FIFO_buffer_fast_input）。需要读取时先判断FIFO长度足够长，然后直接分配出读取内存指针。
        分配出去一段空间并不意味着会失去它，使用者完全可以读了100B的空间，但要求FIFO释放50B，这样做的好处是可以在找到帧尾
    后，使FIFO刚好弹出这一帧，不影响下次读取。有利于不定长数据的分解。
        也就是说分配函数是可以随时使用的（注意其返回值是实际分配长度）。对于释放函数，输出释放函数直接使用会清除一部分FIFO，
    输入释放函数直接使用会导致内存区数据错误。

底层原理：
        此库中代码实现了一种FIFO，基于已存在的一维数组做内存区，以环形FIFO的流控方法处理数据。此FIFO拥有向外分配一段
    输入或输出连续内存区的指针的功能，可以被传递给DMA或者其他程序，当输入或输出完毕使需要使用释放函数表示输入或输出完成。
        为了实现这样的功能，FIFO中有一段影子内存，此内存是用于输入和输出内存的中转区，其大小由用户指定，请求分配的连续
    内存不得超过影子内存大小，否则会出现错误。并且设定影子内存的大小不得超过总内存大小的一半，否则会出现未知错误。
        影子内存位于内存区结尾，其内容将和开头处相同大小的内存区内容保持一致，保持一致的复制过程在写入时完成，对于单字节
    写入，增加的时间并不长，对于多字节写入函数的判断分支很多，实际执行长度也不长，不占用太多时间，但维护起来很复杂。
        因为影子内存区域的内容需要多写一份，所以当总内存区大小:影子内存大小的比值越大，需要产生复制动作的占比就越少，花费
    时间就越接近单个写入。影子内存刚好是总内存一半时，每次写入都要多写一份数据，是极端情况。（实际上单字节写入耗费时间并不
    只花费在写入上，多写一份的影响不是两倍）
